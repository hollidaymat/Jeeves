{
  "originalPath": "/home/jeeves/signal-cursor-controller/src/index.ts",
  "content": "/**\n * Jeeves - Your AI Employee\n * Main entry point\n * Updated: max_tokens now 8000 for complete file generation\n */\n\nimport { config, validateConfig, getOwnerNumber } from './config.js';\nimport { logger } from './utils/logger.js';\nimport { scanProjects } from './core/project-scanner.js';\nimport { registerInterface, handleMessage, sendResponse } from './core/handler.js';\nimport { webInterface } from './interfaces/web.js';\nimport { mockInterface } from './interfaces/mock.js';\nimport { signalInterface } from './interfaces/signal.js';\nimport { initMemory } from './core/memory.js';\nimport { initTrust } from './core/trust.js';\n\nfunction formatDuration(ms: number): string {\n  const s = Math.floor(ms / 1000);\n  if (s < 60) return `${s}s`;\n  const m = Math.floor(s / 60);\n  if (m < 60) return `${m}m`;\n  const h = Math.floor(m / 60);\n  const rm = m % 60;\n  return rm > 0 ? `${h}h ${rm}m` : `${h}h`;\n}\n\nasync function main() {\n  console.log(`\n  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n  â•‘                                                           â•‘\n  â•‘        â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—       â•‘\n  â•‘        â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•       â•‘\n  â•‘        â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—       â•‘\n  â•‘   â–ˆâ–ˆ   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â•  â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘       â•‘\n  â•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘       â•‘\n  â•‘    â•šâ•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•  â•šâ•â•â•â•  â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•       â•‘\n  â•‘                                                           â•‘\n  â•‘   JEEVES v2.0.0                                           â•‘\n  â•‘   Your AI Employee                                        â•‘\n  â•‘                                                           â•‘\n  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  `);\n\n  // Validate configuration\n  const validation = validateConfig();\n  if (!validation.valid) {\n    logger.error('Configuration validation failed:');\n    validation.errors.forEach(err => logger.error(`  - ${err}`));\n    logger.info('Copy config.example.json to config.json and update settings');\n    logger.info('Set ANTHROPIC_API_KEY in .env file');\n    process.exit(1);\n  }\n\n  // Scan for projects\n  logger.info('Initializing...');\n  const projectIndex = scanProjects();\n  logger.info(`Loaded ${projectIndex.projects.size} projects`);\n\n  // Initialize memory system\n  initMemory();\n\n  // Initialize trust system\n  initTrust();\n\n  // Initialize alias store (learned command aliases)\n  const { initAliasStore } = await import('./core/alias-store.js');\n  await initAliasStore();\n\n  // Set up message handling\n  const messageHandler = async (message: Parameters<typeof handleMessage>[0]) => {\n    const response = await handleMessage(message);\n    if (response) {\n      await sendResponse(response, message.interface);\n    }\n  };\n\n  // Register and start web interface\n  webInterface.onMessage(messageHandler);\n  registerInterface(webInterface);\n  await webInterface.start();\n  if (config.voice?.enabled) {\n    logger.info('Voice tablet interface available at /voice and /voice/test');\n  }\n\n  // Register mock interface for testing\n  mockInterface.onMessage(messageHandler);\n  registerInterface(mockInterface);\n  await mockInterface.start();\n\n  // Register and start Signal interface (Linux only)\n  signalInterface.onMessage(messageHandler);\n  registerInterface(signalInterface);\n  await signalInterface.start();\n\n  // Start Knowledge Scout loop\n  try {\n    const { startScoutLoop } = await import('./capabilities/scout/loop.js');\n    startScoutLoop();\n    logger.info('Knowledge Scout started');\n  } catch (err) {\n    logger.debug('Knowledge Scout not started', { error: String(err) });\n  }\n\n  // Start Security Monitor\n  try {\n    const { startSecurityMonitor, setSecurityBroadcast } = await import('./capabilities/security/monitor.js');\n    startSecurityMonitor();\n    // Wire security broadcasts to web UI\n    import('./interfaces/web.js').then(({ webInterface }) => {\n      setSecurityBroadcast((type, payload) => {\n        (webInterface as any).broadcast?.({ type, payload });\n      });\n    }).catch(() => {});\n    logger.info('Security Guardian started');\n  } catch (err) {\n    logger.debug('Security Guardian not started', { error: String(err) });\n  }\n\n  // Initialize Decision Recording\n  try {\n    const { initDecisionTable } = await import('./capabilities/twin/decision-recorder.js');\n    initDecisionTable();\n    logger.info('Decision recorder initialized');\n  } catch (err) {\n    logger.debug('Decision recorder not started', { error: String(err) });\n  }\n\n  // Start Self-Update Checker\n  try {\n    const { startUpdateChecker, setUpdateBroadcast, setActiveTaskChecker } = await import('./capabilities/self/updater.js');\n    // Wire broadcasts\n    import('./interfaces/web.js').then(({ webInterface }) => {\n      setUpdateBroadcast((type, payload) => {\n        (webInterface as any).broadcast?.({ type, payload });\n      });\n    }).catch(() => {});\n    // Wire active task checker\n    import('./integrations/cursor-orchestrator.js').then(({ getActiveCursorTasks }) => {\n      setActiveTaskChecker(() => getActiveCursorTasks().length > 0);\n    }).catch(() => {});\n    startUpdateChecker();\n    logger.info('Self-update checker started');\n  } catch (err) {\n    logger.debug('Self-update checker not started', { error: String(err) });\n  }\n\n  // Start Scheduler + register all handler functions\n  try {\n    const { startScheduler } = await import('./capabilities/scheduler/engine.js');\n    \n    // Register scheduled task handlers\n    const { registerBriefingHandler } = await import('./capabilities/scheduler/briefing.js');\n    registerBriefingHandler();\n    \n    const { registerUptimeHandler } = await import('./capabilities/security/uptime.js');\n    registerUptimeHandler();\n    \n    const { registerChangelogHandler } = await import('./capabilities/self/changelog.js');\n    registerChangelogHandler();\n    \n    const { registerCostAdvisorHandler } = await import('./capabilities/revenue/cost-advisor.js');\n    registerCostAdvisorHandler();\n\n    // Register new monitoring scheduled handlers\n    const { registerHandler, addSchedule } = await import('./capabilities/scheduler/engine.js');\n\n    // Daily SMART disk health check\n    registerHandler('disk_health_check', async () => {\n      try {\n        const { getSmartHealth } = await import('./homelab/system/smart-monitor.js');\n        const report = await getSmartHealth();\n        const { addTimelineEvent } = await import('./capabilities/timeline/timeline.js');\n        addTimelineEvent('scheduler', 'system', `Disk health check: ${report.summary}`, report.overallHealthy ? 'info' : 'warning');\n        if (!report.overallHealthy && signalInterface.isAvailable()) {\n          const { isMuted, shouldSendNow, queueNotification } = await import('./capabilities/notifications/quiet-hours.js');\n          if (!isMuted()) {\n            const msg = `âš ï¸ Disk health alert: ${report.summary}`;\n            if (shouldSendNow('critical')) {\n              await signalInterface.send({ recipient: getOwnerNumber(), content: msg });\n            } else {\n              queueNotification(msg, 'critical', 'disk-health');\n            }\n          }\n        }\n      } catch { /* ignore */ }\n    });\n    addSchedule('Daily disk health', '06:00', 'disk_health_check');\n\n    // Weekly Docker cleanup\n    registerHandler('docker_cleanup', async () => {\n      try {\n        const { runCleanup } = await import('./homelab/system/docker-cleanup.js');\n        const result = await runCleanup();\n        const { addTimelineEvent } = await import('./capabilities/timeline/timeline.js');\n        addTimelineEvent('scheduler', 'system', `Docker cleanup: ${result.message}`, 'info');\n      } catch { /* ignore */ }\n    });\n    addSchedule('Weekly Docker cleanup', '03:00:0', 'docker_cleanup'); // Sunday 3am\n\n    // Daily container log scan\n    registerHandler('log_error_scan', async () => {\n      try {\n        const { scanContainerLogs } = await import('./homelab/system/log-scanner.js');\n        const result = await scanContainerLogs(1440); // last 24h\n        const { addTimelineEvent } = await import('./capabilities/timeline/timeline.js');\n        if (result.errors.length > 0) {\n          addTimelineEvent('scheduler', 'system', `Log scan: ${result.errors.length} errors across ${result.containersScanned} containers`, 'warning');\n        }\n      } catch { /* ignore */ }\n    });\n    addSchedule('Daily log error scan', '07:00', 'log_error_scan');\n\n    // Daily SSL cert check\n    registerHandler('ssl_cert_check', async () => {\n      try {\n        const { checkCertificates } = await import('./homelab/system/ssl-monitor.js');\n        const report = await checkCertificates();\n        const expiring = report.certs.filter(c => c.status !== 'ok');\n        if (expiring.length > 0 && signalInterface.isAvailable()) {\n          const { isMuted, shouldSendNow, queueNotification } = await import('./capabilities/notifications/quiet-hours.js');\n          if (!isMuted()) {\n            const msg = `ðŸ”’ SSL alert: ${expiring.map(c => `${c.domain} (${c.daysLeft}d)`).join(', ')}`;\n            if (shouldSendNow('critical')) {\n              await signalInterface.send({ recipient: getOwnerNumber(), content: msg });\n            } else {\n              queueNotification(msg, 'critical', 'ssl-monitor');\n            }\n          }\n        }\n      } catch { /* ignore */ }\n    });\n    addSchedule('Daily SSL cert check', '08:00', 'ssl_cert_check');\n\n    // Daily image update check\n    registerHandler('image_update_check', async () => {\n      try {\n        const { checkImageUpdates } = await import('./homelab/system/image-updates.js');\n        const result = await checkImageUpdates();\n        const { addTimelineEvent } = await import('./capabilities/timeline/timeline.js');\n        addTimelineEvent('scheduler', 'system', `Image update check: ${result.message}`, 'info');\n      } catch { /* ignore */ }\n    });\n    addSchedule('Daily image update check', '09:00', 'image_update_check');\n\n    // Daily speed test\n    registerHandler('speed_test', async () => {\n      try {\n        const { runSpeedTest } = await import('./homelab/system/speed-test.js');\n        const result = await runSpeedTest();\n        const { addTimelineEvent } = await import('./capabilities/timeline/timeline.js');\n        if (result) {\n          addTimelineEvent('scheduler', 'system', `Speed test: ${result.download} Mbps down / ${result.upload} Mbps up`, 'info');\n        }\n      } catch { /* ignore */ }\n    });\n    addSchedule('Daily speed test', '12:00', 'speed_test');\n\n    // Custom schedule executor (runs every minute to check if any custom schedules are due)\n    registerHandler('custom_schedule_check', async () => {\n      try {\n        const { getSchedulesDueNow } = await import('./capabilities/scheduler/custom-schedules.js');\n        const due = getSchedulesDueNow();\n        const { isMuted } = await import('./capabilities/notifications/quiet-hours.js');\n        for (const schedule of due) {\n          if (!isMuted() && signalInterface.isAvailable()) {\n            await signalInterface.send({\n              recipient: getOwnerNumber(),\n              content: `ðŸ“‹ Scheduled: ${schedule.action}`,\n            });\n          }\n        }\n      } catch { /* ignore */ }\n    });\n    addSchedule('Custom schedule check', 60000, 'custom_schedule_check'); // Every 60 seconds\n\n    // Quiet hours flush (deliver queued notifications when quiet hours end)\n    registerHandler('quiet_hours_flush', async () => {\n      try {\n        const { isQuietHours, flushQueue } = await import('./capabilities/notifications/quiet-hours.js');\n        if (!isQuietHours()) {\n          const { isMuted } = await import('./capabilities/notifications/quiet-hours.js');\n          const queued = flushQueue();\n          if (queued.length > 0 && !isMuted() && signalInterface.isAvailable()) {\n            const summary = queued.map(n => n.message).join('\\n');\n            await signalInterface.send({\n              recipient: getOwnerNumber(),\n              content: `ðŸ“¬ While you were away (${queued.length} notifications):\\n\\n${summary}`,\n            });\n          }\n        }\n      } catch { /* ignore */ }\n    });\n    addSchedule('Quiet hours flush', 300000, 'quiet_hours_flush'); // Every 5 minutes\n\n    startScheduler();\n    logger.info('Scheduler started with default schedules');\n  } catch (err) {\n    logger.debug('Scheduler not started', { error: String(err) });\n  }\n\n  // Initialize Download Watcher callbacks\n  try {\n    const { onDownloadComplete, onDownloadStall, setDownloadBroadcast } = await import('./homelab/media/download-watcher.js');\n\n    // Signal notification on completion (respects quiet hours)\n    onDownloadComplete(async (download) => {\n      if (signalInterface.isAvailable()) {\n        const icon = download.type === 'movie' ? 'ðŸŽ¬' : 'ðŸ“º';\n        const size = download.size ? ` (${download.size})` : '';\n        const duration = download.completedAt && download.addedAt\n          ? ` in ${formatDuration(download.completedAt - download.addedAt)}`\n          : '';\n        const message = `${icon} Download complete: ${download.title}${size}${duration}`;\n        try {\n          const { isMuted, shouldSendNow, queueNotification } = await import('./capabilities/notifications/quiet-hours.js');\n          if (!isMuted()) {\n            if (shouldSendNow('normal')) {\n              await signalInterface.send({ recipient: getOwnerNumber(), content: message });\n            } else {\n              queueNotification(message, 'normal', 'download-watcher');\n            }\n          }\n        } catch {\n          await signalInterface.send({ recipient: getOwnerNumber(), content: message });\n        }\n        if (config.voice?.enabled) {\n          import('./integrations/voice/voice-server.js').then(({ broadcastVoiceNotification }) => {\n            broadcastVoiceNotification({ message, priority: 'normal', title: 'Download' });\n          }).catch(() => {});\n        }\n        // Log to timeline\n        try {\n          const { addTimelineEvent } = await import('./capabilities/timeline/timeline.js');\n          addTimelineEvent('download-watcher', 'download', `Completed: ${download.title}`, 'info');\n        } catch { /* skip */ }\n      }\n    });\n\n    // Log stalls (could also alert via Signal if desired)\n    onDownloadStall(async (download, action) => {\n      logger.warn('[download-watcher] Stall detected', { title: download.title, action });\n      // Log to timeline\n      try {\n        const { addTimelineEvent } = await import('./capabilities/timeline/timeline.js');\n        addTimelineEvent('download-watcher', 'download', `Stall: ${download.title} â€” ${action}`, 'warning');\n      } catch { /* skip */ }\n      // Notify via Signal for restarts (respects mute)\n      if (download.restarted && signalInterface.isAvailable()) {\n        const stallMessage = `âš ï¸ ${action}`;\n        try {\n          const { isMuted } = await import('./capabilities/notifications/quiet-hours.js');\n          if (!isMuted()) {\n            await signalInterface.send({\n              recipient: getOwnerNumber(),\n              content: stallMessage,\n            });\n          }\n        } catch {\n          await signalInterface.send({ recipient: getOwnerNumber(), content: stallMessage });\n        }\n        if (config.voice?.enabled) {\n          import('./integrations/voice/voice-server.js').then(({ broadcastVoiceNotification }) => {\n            broadcastVoiceNotification({ message: stallMessage, priority: 'high', title: 'Download' });\n          }).catch(() => {});\n        }\n      }\n    });\n\n    // WebSocket broadcast\n    import('./interfaces/web.js').then(({ webInterface }) => {\n      setDownloadBroadcast((status) => {\n        (webInterface as any).broadcast?.({ type: 'download_status', payload: status });\n      });\n    }).catch(() => {});\n\n    logger.info('Download watcher callbacks registered');\n  } catch (err) {\n    logger.debug('Download watcher not initialized', { error: String(err) });\n  }\n\n  // Initialize Reminders (re-schedule pending from disk)\n  try {\n    const { initReminders, setReminderCallback } = await import('./capabilities/reminders/reminders.js');\n    setReminderCallback(async (message: string) => {\n      if (signalInterface.isAvailable()) {\n        try {\n          const { isMuted } = await import('./capabilities/notifications/quiet-hours.js');\n          if (!isMuted()) {\n            await signalInterface.send({\n              recipient: getOwnerNumber(),\n              content: message,\n            });\n          }\n        } catch {\n          await signalInterface.send({ recipient: getOwnerNumber(), content: message });\n        }\n      }\n    });\n    initReminders();\n    logger.info('Reminders initialized');\n  } catch (err) {\n    logger.debug('Reminders not initialized', { error: String(err) });\n  }\n\n  // Initialize Timeline event tracking\n  try {\n    const { addTimelineEvent } = await import('./capabilities/timeline/timeline.js');\n    addTimelineEvent('system', 'system', 'Jeeves started', 'info');\n    logger.info('Timeline initialized');\n  } catch (err) {\n    logger.debug('Timeline not initialized', { error: String(err) });\n  }\n\n  logger.info('System ready');\n  logger.info(`Open http://${config.server.host}:${config.server.port} in your browser`);\n  if (signalInterface.isAvailable()) {\n    logger.info(`Signal interface active - send messages to ${config.signal.number}`);\n  } else if (process.platform !== 'win32') {\n    logger.info('Signal interface offline - check signal-cli daemon');\n  }\n  logger.info('Press Ctrl+C to stop');\n\n  // Graceful shutdown handler\n  let isShuttingDown = false;\n  const shutdown = async (signal: string) => {\n    if (isShuttingDown) return;\n    isShuttingDown = true;\n    \n    logger.info(`Shutting down (${signal})...`);\n    \n    try {\n      // Close all interfaces\n      await Promise.race([\n        Promise.all([\n          signalInterface.stop().catch(() => {}),\n          webInterface.stop().catch(() => {}),\n          mockInterface.stop().catch(() => {})\n        ]),\n        new Promise(resolve => setTimeout(resolve, 2000)) // 2s timeout\n      ]);\n    } catch {\n      // Ignore errors during shutdown\n    }\n\n      // Stop background loops\n      try {\n        const { stopScoutLoop } = await import('./capabilities/scout/loop.js');\n        stopScoutLoop();\n      } catch {}\n      try {\n        const { stopSecurityMonitor } = await import('./capabilities/security/monitor.js');\n        stopSecurityMonitor();\n      } catch {}\n      try {\n        const { stopUpdateChecker } = await import('./capabilities/self/updater.js');\n        stopUpdateChecker();\n      } catch {}\n      try {\n        const { stopScheduler } = await import('./capabilities/scheduler/engine.js');\n        stopScheduler();\n      } catch {}\n    \n    process.exit(0);\n  };\n\n  // Handle various shutdown signals\n  process.on('SIGINT', () => shutdown('SIGINT'));\n  process.on('SIGTERM', () => shutdown('SIGTERM'));\n  process.on('SIGHUP', () => shutdown('SIGHUP'));\n  \n  // Handle tsx watch restarts on Windows\n  process.on('exit', () => {\n    if (!isShuttingDown) {\n      try {\n        webInterface.stop().catch(() => {});\n      } catch {\n        // Ignore\n      }\n    }\n  });\n\n  // Handle uncaught errors gracefully\n  process.on('uncaughtException', (error) => {\n    logger.error('Uncaught exception', { error: String(error) });\n    shutdown('uncaughtException');\n  });\n}\n\nmain().catch((error) => {\n  logger.error('Fatal error:', { error: String(error) });\n  process.exit(1);\n});\n",
  "timestamp": "2026-02-14T17:10:19.584Z",
  "taskId": "dev-1771089002224",
  "description": "Add UUID import to main entry point"
}
{
  "originalPath": "/home/jeeves/signal-cursor-controller/src/devtools/test-runner.ts",
  "content": "// Jeeves dev test Confirmation\n// Jeeves dev test Confirmation\n// Jeeves dev test Confirmation\n// Jeeves dev test Confirmation\n// Jeeves dev test 5\n/**\n * Test Runner (devtools)\n * Run tests and parse results into structured data for the dev loop.\n */\n\nimport { spawn } from 'child_process';\nimport { existsSync } from 'fs';\nimport { resolve } from 'path';\n\nconst JEEVES_ROOT = '/home/jeeves/signal-cursor-controller';\nconst JEEVES_QA_PATH = resolve(JEEVES_ROOT, '..', 'jeeves-qa');\n\n/** True if path is inside project root and NOT jeeves-qa. Used so develop never runs QA. */\nfunction isInRepoTestPath(filePath: string): boolean {\n  const abs = resolve(JEEVES_ROOT, filePath);\n  return abs.startsWith(JEEVES_ROOT) && !abs.startsWith(JEEVES_QA_PATH);\n}\n\nexport interface TestResult {\n  suite: string;\n  passed: number;\n  failed: number;\n  skipped: number;\n  total: number;\n  duration: number;\n  failures: TestFailure[];\n  output: string;\n}\n\nexport interface TestFailure {\n  test: string;\n  error: string;\n  file?: string;\n  line?: number;\n  expected?: string;\n  actual?: string;\n}\n\nfunction runProcess(\n  executable: string,\n  args: string[],\n  cwd: string,\n  timeoutMs: number\n): Promise<{ stdout: string; stderr: string; exitCode: number }> {\n  return new Promise((resolvePromise) => {\n    const proc = spawn(executable, args, {\n      cwd,\n      env: { ...process.env },\n      stdio: ['ignore', 'pipe', 'pipe'],\n    });\n    let stdout = '';\n    let stderr = '';\n    proc.stdout?.on('data', (chunk: Buffer) => {\n      stdout += chunk.toString();\n    });\n    proc.stderr?.on('data', (chunk: Buffer) => {\n      stderr += chunk.toString();\n    });\n    const t = setTimeout(() => {\n      proc.kill('SIGTERM');\n      setTimeout(() => proc.kill('SIGKILL'), 5000);\n    }, timeoutMs);\n    proc.on('close', (code) => {\n      clearTimeout(t);\n      resolvePromise({\n        stdout,\n        stderr,\n        exitCode: code ?? -1,\n      });\n    });\n    proc.on('error', () => {\n      clearTimeout(t);\n      resolvePromise({ stdout: '', stderr: 'spawn error', exitCode: -1 });\n    });\n  });\n}\n\nfunction parseTestOutput(raw: string, suite: string): TestResult {\n  const output = raw.slice(0, 5000);\n  const failures: TestFailure[] = [];\n\n  try {\n    const jsonMatch = raw.match(/\\{[\\s\\S]*\"passed\"[\\s\\S]*\"failed\"[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      const parsed = JSON.parse(jsonMatch[0]);\n      const passed = parsed.passed ?? 0;\n      const failed = parsed.failed ?? 0;\n      const skipped = parsed.skipped ?? 0;\n      return {\n        suite,\n        passed,\n        failed,\n        skipped,\n        total: passed + failed + skipped,\n        duration: parsed.duration ?? 0,\n        failures: (parsed.failures ?? []).map((f: Record<string, unknown>) => ({\n          test: String(f.name ?? f.test ?? 'unknown'),\n          error: String(f.error ?? f.message ?? 'unknown error'),\n          file: f.file as string | undefined,\n          line: f.line as number | undefined,\n          expected: f.expected as string | undefined,\n          actual: f.actual as string | undefined,\n        })),\n        output,\n      };\n    }\n  } catch {\n    /* not JSON */\n  }\n\n  let passed = 0;\n  let failed = 0;\n  let skipped = 0;\n  const summaryMatch = raw.match(/(\\d+)\\s+pass(?:ing|ed).*?(\\d+)\\s+fail(?:ing|ed)?/i);\n  if (summaryMatch) {\n    passed = parseInt(summaryMatch[1], 10);\n    failed = parseInt(summaryMatch[2], 10);\n  }\n  const altMatch = raw.match(/Tests?:\\s*(\\d+)\\s+passed.*?(\\d+)\\s+failed/i);\n  if (altMatch) {\n    passed = parseInt(altMatch[1], 10);\n    failed = parseInt(altMatch[2], 10);\n  }\n  const failureBlocks = raw.split(/(?:FAIL|Error|✗|✕|×)\\s+/);\n  for (const block of failureBlocks.slice(1)) {\n    const firstLine = block.split('\\n')[0]?.trim();\n    if (firstLine) {\n      failures.push({\n        test: firstLine.slice(0, 100),\n        error: block.slice(0, 300).trim(),\n      });\n    }\n  }\n\n  return {\n    suite,\n    passed,\n    failed: failed || failures.length,\n    skipped,\n    total: passed + (failed || failures.length) + skipped,\n    duration: 0,\n    failures,\n    output,\n  };\n}\n\nexport async function runSelfTests(scenario?: string): Promise<TestResult> {\n  if (!existsSync(JEEVES_QA_PATH) || !existsSync(resolve(JEEVES_QA_PATH, 'src/index.ts'))) {\n    return {\n      suite: 'jeeves-qa',\n      passed: 0,\n      failed: 0,\n      skipped: 0,\n      total: 0,\n      duration: 0,\n      failures: [{ test: 'jeeves-qa', error: 'jeeves-qa not found at ' + JEEVES_QA_PATH }],\n      output: '',\n    };\n  }\n  const args = ['tsx', 'src/index.ts', '--json', '--no-llm', '--host', 'http://localhost:3847'];\n  if (scenario) args.push('--scenario', scenario);\n  const result = await runProcess('npx', args, JEEVES_QA_PATH, 120_000);\n  return parseTestOutput(result.stdout + result.stderr, 'jeeves-qa');\n}\n\n/** In-repo test files only. Develop commands must never run jeeves-qa. */\nconst PROJECT_TEST_FILES = ['tests/parser.test.ts', 'tests/routing.test.ts'];\n\n/** Smoke: routing tests only (~1–2s). Used by dev loop when testMode is smoke-test. */\nexport async function runSmokeTest(): Promise<TestResult> {\n  return runProjectTests('tests/routing.test.ts');\n}\n\nexport async function runProjectTests(testFile?: string): Promise<TestResult> {\n  const requested = testFile ? [testFile] : PROJECT_TEST_FILES;\n  const files = requested.filter((f) => {\n    if (!isInRepoTestPath(f)) {\n      return false;\n    }\n    return true;\n  });\n  if (requested.length > 0 && files.length === 0) {\n    return {\n      suite: 'project',\n      passed: 0,\n      failed: 1,\n      skipped: 0,\n      total: 1,\n      duration: 0,\n      failures: [{ test: 'runProjectTests', error: 'Only in-repo tests under JEEVES_ROOT are allowed. jeeves-qa is never run by develop.' }],\n      output: '',\n    };\n  }\n  let combined = '';\n  for (const file of files) {\n    const result = await runProcess('npx', ['tsx', file], JEEVES_ROOT, 60_000);\n    combined += result.stdout + result.stderr;\n  }\n  return parseTestOutput(combined, 'project');\n}\n\nexport async function runSpecificTest(filePath: string): Promise<TestResult> {\n  const result = await runProcess('npx', ['tsx', filePath], JEEVES_ROOT, 60_000);\n  return parseTestOutput(result.stdout + result.stderr, filePath);\n}\n\nexport async function runTypeCheck(): Promise<TestResult> {\n  const result = await runProcess('npx', ['tsc', '--noEmit'], JEEVES_ROOT, 30_000);\n  const raw = result.stdout + result.stderr;\n  const errors = raw.split('\\n').filter((l) => l.includes('error TS'));\n  return {\n    suite: 'typescript-check',\n    passed: errors.length === 0 ? 1 : 0,\n    failed: errors.length > 0 ? 1 : 0,\n    skipped: 0,\n    total: 1,\n    duration: 0,\n    failures: errors.map((e) => ({\n      test: 'type-check',\n      error: e.trim(),\n      file: e.split('(')[0]?.trim(),\n      line: parseInt(e.match(/\\((\\d+),/)?.[1] ?? '0', 10),\n    })),\n    output: raw.slice(0, 5000),\n  };\n}\n",
  "timestamp": "2026-02-14T17:17:33.049Z",
  "taskId": "dev-1771089419148",
  "description": "Add comment at top"
}